
def main(input_ply, swc_file, frames_output_path, plot_node_v = False): 
    """ 
    Main function to generate a movie visualizing neuron simulation data mapped onto a 3D mesh. This generates a movie with simulated voltage data mapped onto a 3D mesh of a neuron over time.
    :param input_ply: the input PLY mesh file path
    :param output_path: the folder to save output PLY frames
    :param movie_output_path: the output movie file path/name:
    :param plot_node_v: boolean to indicate if sample individual node voltages should be plotted]
    """
    from swcToolkit import swcToolkit
    swc = swcToolkit()
    from neuron import h, gui
    import numpy as np
    import matplotlib.pyplot as plt
    from pprint import pprint
    import os
    
    plot_on = False
    swc_data = swc.read_swc_file(swc_file)  # Read SWC data
    # colorbar_output_path = os.path.join("C:\\Users\\emanu\\USC-Summer\\Colorbar", "colorbar.png")
    # Generate NEURON data (collect voltages, sec_list, time)
    if not os.path.exists(frames_output_path): 
        os.makedirs(frames_output_path)


    movie_output_path, colorbar_output_path = movie_colorbar_output_path_gen(swc_file)

    time, voltages, sec_per_nodes, sec_list = nrn_data_gen(swc_file, plot_on) # stim_amp=0.1, stim_dur=1, tstop=10
    voltages_per_node = give_mapped_nodes_voltages(voltages, sec_per_nodes, sec_list)
    colors, cmap_name, vmin, vmax = voltages_to_colors(voltages_per_node)
    swc_centers = get_swc_centers(swc_data)
    color_ply_faces_over_time(input_ply, swc_centers, colors, frames_output_path, prefix = "neuron")
    generate_mov(frames_output_path, movie_output_path, time_array = time)
    save_voltage_colorbar(cmap_name, vmin, vmax, colorbar_output_path)

    if plot_node_v: 
        plt.figure()
        for i in range(len(voltages_per_node)):
            plt.plot(time, voltages_per_node[i], label=i + 1)
        plt.xlabel('Time (ms)')
        plt.ylabel('Voltage per Node (mV)')
        plt.legend()
        plt.show()
    
    ### Enter a remove_frames function
    
    remove_frames(frames_output_path)


    # overlay_timer_and_colorbar(movie_output_path, movie_output_path, time, colorbar_output_path)
    # overlay_colorbar_and_time(output_path, colorbar_output_path, movie_output_path, time, fps = 60)

def nrn_data_gen(swc_file, plot_on, stim_amp=0.1, stim_dur=1, tstop=10):
    """
    Generates voltage data with neuron for nodes in a given .swc file. 
    :param swc_file: path to the swc file on the users computer
    :param plot_on: boolean to indicate if voltage data for each section generated by NEURON should be plotted
    :param stim_amp: amplitude of current injection in nA
    :param stim_dur: duration of current injection in ms
    :param tstop: stop parameter for NEURON simulation in ms
    :return: time array, voltages array (nodes, time), mapping of nodes to which section NEURON allocates them to, list of section names"""

    from neuron import h, gui
    import numpy as np
    import matplotlib.pyplot as plt
    from swcToolkit import swcToolkit
    swc = swcToolkit()

    swc_data = swc.read_swc_file(swc_file)  # Read SWC data

    # Load SWC morphology'
    h.load_file("import3d.hoc")
    morph = h.Import3d_SWC_read()
    morph.input(swc_file)
    i3d = h.Import3d_GUI(morph, 0)
    i3d.instantiate(None)

    # Insert biophysics (Hodgkin-Huxley everywhere)
    for sec in h.allsec():
        sec.insert('hh')

    # Stimulus (inject current at soma[0])
    stim = h.IClamp(h.soma[0](0.5))
    stim.delay = 5
    stim.dur = stim_dur
    stim.amp = stim_amp

    # Recording
    t_vec = h.Vector().record(h._ref_t)
    v_vecs = []
    sec_list = []
    coords = []

    for sec in h.allsec():
        v = h.Vector().record(sec(0.5)._ref_v)  # record midpoint
        v_vecs.append(v)
        sec_list.append(sec.name())
        # get 3D coordinates of midpoint
        npts = int(h.n3d(sec=sec))  # number of pt3d points in this section
        if npts > 1:
            # length along the section
            L = sec.L
            mid_loc = 0.5 * L  

            # find position in pt3d
            arc_length = 0
            for i in range(npts-1):
                x1, y1, z1 = h.x3d(i, sec=sec), h.y3d(i, sec=sec), h.z3d(i, sec=sec)
                x2, y2, z2 = h.x3d(i+1, sec=sec), h.y3d(i+1, sec=sec), h.z3d(i+1, sec=sec)
                seg_len = ((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)**0.5
                if arc_length + seg_len >= mid_loc:
                    frac = (mid_loc - arc_length) / seg_len
                    xm = x1 + frac*(x2-x1)
                    ym = y1 + frac*(y2-y1)
                    zm = z1 + frac*(z2-z1)
                    coords.append((xm, ym, zm))
                    break
                arc_length += seg_len
        else:
            # fallback: just take first point
            coords.append((h.x3d(0, sec=sec), h.y3d(0, sec=sec), h.z3d(0, sec=sec)))

    sections = {}
    for idx in range(len(sec_list)): 
        sections.update({sec_list[idx]: coords[idx]})
    # print(sections)
       
    # Run sim
    h.finitialize(-65)
    h.continuerun(tstop)

    voltages = np.array([np.array(v) for v in v_vecs])  # shape = (nodes, time)
    time = np.array(t_vec)

    nodes_per_sec = build_node_map(swc_data, sections)

    # Plot voltage data
    if plot_on == True: 
        plt.figure()
        for i in range(len(sec_list)):
            plt.plot(time, voltages[i], label=sec_list[i])
        plt.xlabel('Time (ms)')
        plt.ylabel('Voltage (mV)')
        plt.legend()
        plt.show()
    return time, voltages, nodes_per_sec, sec_list

def build_node_map(data, sections):
    """
    Maps each node in the SWC data to the closest section in the NEURON model based on 3D coordinates.
    :param data: swc data as read by swcToolkit
    :param sections: A list of section names and the the 3D coordinate of their midpoints 
    :return mapped_nodes: dictionary mapping node IDs to seection names
    """
    import neuron as h 
    import numpy as np

    closest_seg = None
    min_dist = None
    mapped_nodes = {} 

    for id in range(len(data)): 
        # print("Node being checked: ", id + 1)
        x, y, z = data['x'][id], data['y'][id], data['z'][id]
        min_dist = None
        # print(x, y, z)
        for key in sections: 
            sec_x, sec_y, sec_z = sections[key][0], sections[key][1], sections[key][2]
            # print(sec_x, sec_y, sec_z)
            dist = np.sqrt((x - sec_x)**2 + (y - sec_y)**2 + (z - sec_z)**2)
            # print(id, key, dist) 
            if min_dist is None: 
                min_dist = dist
                closest_seg = key
            elif (dist < min_dist): 
                min_dist = dist 
                closest_seg = key
        mapped_nodes.update({id + 1: closest_seg})
    return mapped_nodes

def give_mapped_nodes_voltages(voltages, mapped_nodes, sec_list): 
    """
    Takes the mapped nodes to each section of the NEURON model and returns the voltages for each node
    :param voltages: (nodes, time) voltage data for each section generated by NEURON
    :param mapped_nodes: dictionary mapping node IDs to their corresponding section names from NEURON simulation
    :param sec_list: list of section names in the order NEURON allocated them
    :return voltages_per_node: (nodes, time) voltage data for each node in the SWC file over the length of simulation
    """
    voltages_per_node = []
    for i in range(len(sec_list)): 
        for j in mapped_nodes: 
            # print(sec_list[i], mapped_nodes[j])
            if sec_list[i] == mapped_nodes[j]: 
                voltages_per_node.append(voltages[i])
    # print(np.shape(voltages_per_node))
    return voltages_per_node

def voltages_to_colors(voltages, cmap_name="plasma"):
    """
    Takes voltage data and converts it to RGB colors using a colormap.
    :param voltages: (nodes, time) np.ndarray of voltage data
    :param cmap_name: str, name of matplotlib colormap to use (default 'plasma')
    :return colors: (nodes, time, 3) np.ndarray of RGB values [0-255] stored with the swc nodes and the color at each time point
    :return cmap_name: str, name of the colormap used
    :return vmin: float, minimum voltage value used for normalization, this is useful for colorbar generation
    :return vmax: float, maximum voltage value used for normalization, this is useful for colorbar generation"""

    import matplotlib.cm as cm
    import numpy as np
    # voltages: (nodes, time)
    vmin, vmax = np.min(voltages), np.max(voltages)
    normed = (voltages - vmin) / (vmax - vmin)
    normed = np.clip(normed, 0, 1)

    cmap = cm.get_cmap(cmap_name)
    colors = (cmap(normed)[:, :, :3] * 255).astype(np.uint8)  # RGB 0-255
    return colors, cmap_name, vmin, vmax # shape = (nodes, time, 3)

def get_swc_centers(data):
    """
    Obtains the 3D coordinates of each node in the SWC data. 
    :param data: swc data as read by swcToolkit
    :return centers_list: list of [x, y, z] coordinates for each node center in the SWC file
    """
    centers_list = [] 
    for i in range(len(data)): 
        x, y, z = data['x'][i], data['y'][i], data['z'][i]
        centers_list.append([x, y, z])
    return centers_list

def color_ply_faces_over_time(ply_path, swc_points, swc_colors_time, out_dir, prefix="frame"):
    """
    Colors ply file mesh faces based on swc node voltage data over time and saves a series of ply files to be used as frames in movie generation. The color of each face is determined by the voltage at the nearest SWC node center at each time point. 

    :param ply_path: str, path to input base PLY mesh
    :param swc_points: (N, 3) np.ndarray, XYZ coords of SWC nodes
    :param swc_colors_time: (N, T, 3) np.ndarray, RGB values [0-255] for each node at each time point 
    :param out_dir: str, folder where PLY frames will be saved
    :param prefix: str, filename prefix for generated frames (default 'frame')    
    """
    import numpy as np
    import trimesh
    from scipy.spatial import cKDTree
    import os

    os.makedirs(out_dir, exist_ok=True)

    # Load base mesh
    mesh = trimesh.load(ply_path)
    vertices = np.array(mesh.vertices)
    faces = np.array(mesh.faces)

    # Build KDTree to map vertices -> SWC nodes
    tree = cKDTree(swc_points)
    _, nearest_idx = tree.query(vertices)

    n_timepoints = swc_colors_time.shape[1]

    for t in range(n_timepoints):
        # Get SWC colors for this time step
        swc_colors = swc_colors_time[:, t, :]

        # Map vertex colors
        vertex_colors = swc_colors[nearest_idx]

        # Compute face colors (average of vertex colors)
        face_colors = []
        for f in faces:
            face_colors.append(vertex_colors[f].mean(axis=0))
        face_colors = np.array(face_colors).astype(np.uint8)

        # Assign and save new mesh with face colors
        # mesh.visual.face_colors = face_colors
        alpha = np.full((face_colors.shape[0], 1), 255, dtype=np.uint8)
        mesh.visual.face_colors = np.hstack([face_colors, alpha])

        out_path = os.path.join(out_dir, f"{prefix}_{t:04d}.ply")
        mesh.export(out_path)

        if t % 100 == 0:
            print(f"Saved frame {t}/{n_timepoints}")

def save_voltage_colorbar(cmap_name, vmin, vmax, output_file):
    """
    Saves a colorbar image representing the voltage colormap used during coloring of the mesh to a designated output_path.
    :param cmap_name: str, name of the matplotlib colormap used
    :param vmin: float, minimum voltage value used for normalization
    :param vmax: float, maximum voltage value used for normalization
    :param output_file: str, path to where to save the colorbar image
    """
    import matplotlib.pyplot as plt
    import matplotlib

    cmap = matplotlib.colormaps.get_cmap(cmap_name)  # modern API
    norm = plt.Normalize(vmin=vmin, vmax=vmax)

    fig, ax = plt.subplots(figsize=(0.4, 4))
    fig.subplots_adjust(right=0.5)

    cb = fig.colorbar(
        plt.cm.ScalarMappable(norm=norm, cmap=cmap),
        cax=ax
    )
    cb.set_label("Voltage (mV)")

    fig.savefig(output_file, dpi=150, bbox_inches="tight")
    plt.close(fig)

def generate_mov(ply_folder, movie_output_path, time_array=None): 
    """
    Generates a movie from a series of PLY frames, overlaying a timer in the bottom left corner when provided an array of time points.
    :param ply_folder: str, path to the folder containing all PLY frames
    :param movie_output_path: str, path to the location of where to save the output movie file
    :param time_array: (T,) np.ndarray or list of time points corresponding to each frame, if None no timer is added
    """
    import pyvista as pv
    import imageio.v2 as imageio
    import os
    from PIL import Image, ImageDraw, ImageFont
    import numpy as np

    fps = 60
    ply_files = sorted([f for f in os.listdir(ply_folder) if f.lower().endswith(".ply")])
    frames = []

    plotter = pv.Plotter(off_screen=True, window_size=(1280, 720))

    for i, ply_file in enumerate(ply_files):
        plotter.clear()
        mesh = pv.read(os.path.join(ply_folder, ply_file))

        if "RGBA" in mesh.cell_data:
            plotter.add_mesh(mesh, scalars=mesh.cell_data["RGBA"], rgb=True)
        elif "RGB" in mesh.cell_data:
            plotter.add_mesh(mesh, scalars=mesh.cell_data["RGB"], rgb=True)
        else:
            raise ValueError(f"No RGB(A) data found in {ply_file}")

        plotter.camera_position = 'iso'

        # Screenshot (force RGB)
        img = plotter.screenshot(return_img=True, transparent_background=False)
        img = np.ascontiguousarray(img[:, :, :3])  # drop alpha if present

        # Add Timer in the bottom left corner
        if time_array is not None and i < len(time_array):
            t_val = time_array[i]
            text = f"t = {t_val:.2f} ms"

            pil_img = Image.fromarray(img)
            draw = ImageDraw.Draw(pil_img)

            try:
                font = ImageFont.truetype("arial.ttf", 28)
            except:
                font = ImageFont.load_default()

            # Draw with outline for visibility
            x, y = 20, pil_img.height - 40
            outline_color = "black"
            for dx, dy in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                draw.text((x+dx, y+dy), text, font=font, fill=outline_color)
            draw.text((x, y), text, font=font, fill=(255, 255, 255))

            img = np.array(pil_img)

        frames.append(img)

    imageio.mimsave(movie_output_path, frames, fps=fps)
    print(f"Movie saved to {movie_output_path}")

def remove_frames(dir): 
    """
    Removes all the ply frame files in order to make room for multiple iterations of movie generation. 
    :param dir: str, path to the folder containing the PLY file frames
    """
    import os
    if os.path.exists(dir): 
        for filename in os.listdir(dir):
            file_path = os.path.join(dir, filename)
            if os.path.isfile(file_path) and filename.endswith(".ply"):
                os.remove(file_path)
                # print(f"Deleted file: {file_path}")

    if not os.listdir(dir): 
        os.rmdir(dir)
        print(f"Deleted directory: {dir}") 
    else: 
        print(f"Directory not empty, not deleted: {dir}")

def movie_colorbar_output_path_gen(swc_file): 
    """
    Extracts the base name of the SWC file without its directory path or file extension and creates movie_output_path.
    :param swc_file: str, full path to the SWC file
    """
    import os
    base_name = os.path.basename(swc_file)
    name_without_ext = os.path.splitext(base_name)[0]
    os.makedirs(name_without_ext, exist_ok=True) # Create directory if it doesn't exist 
    movie_output_path = os.path.join(name_without_ext, f"{name_without_ext}.mp4")
    colorbar_ouput_path = os.path.join(name_without_ext, f"{name_without_ext}_colorbar.png")
    return movie_output_path, colorbar_ouput_path


# Example usage
if __name__ == "__main__":
    # input_ply = "C:\\Users\\emanu\\USC-Summer\\SWC_file_copies\\1000_swc_files\\Output_files\\test_retinal_cells_3.ply"
    # frames_output_path = "C:\\Users\\emanu\\OneDrive\\Desktop\\USCResearch\\Frames"
    # movie_output_path = "neuron_movie_with_bar_time.mp4"
    # swc_file = "C:\\Users\\emanu\\USC-Summer\\nrn_sep_files\\test_retinal_cells\\test_retinal_cells_3.swc"
    main(input_ply, swc_file, frames_output_path, plot_node_v = False)


    ### Change so name of movie is name of file generation and you remove all of the frames in the folder prior to generation of new movies. 